
[{"content":"This blog is a record of things I break, fix, and understand better in software, electronics, and embedded systems.\nAs a bonus, I might share some other things too.\n","date":"28 December 2025","externalUrl":null,"permalink":"/","section":"","summary":"","title":"","type":"page"},{"content":" Table of Contents # Intro Shift Register IC SN74HC595\na. ↳Overview\nb. ↳Pin Descriptions\nc. ↳Functional Characteristics\nd. ↳Nomenclature of the 7400 series IC (trivia) Interrupts\na. ↳A Brief Description\nb. ↳Blocking Process\nc. ↳Interrupts in ATMega328P Putting it All Together\na. ↳Writing Bytes to the Shift Register b. ↳The Animation\nc. ↳Interrupt for Interface\nd. ↳Result Conclusion References and Further Reading Foot Notes Intro # Di blog kali ini, kita akan membahas tentang bagaimana menganimasikan 8 LED dengan shift register. Sebelum lanjut, saya mengasumsikan pembaca sudah memahami beberapa hal dasar tentang register, kita akan membahas ini berulang kali kedepannya. Jika ingin tahu, silakan baca blog sebelumnya atau sumber lain. Hello, Bare Metal AVR. 22 December 2025\u0026middot;1347 words\u0026middot;7 mins Jadi, bagaimana caranya menganimasikan 8 LED dengan mikrokontroler? Cara paling sederhana adalah menggunakan 8 pin GPIO dari port yang sama. Contoh, jika kita menggunakan Port B, maka kita perlu mengubah register DDRB sekali dan memanipulasi PORTB untuk setiap frame-nya. Selesai.\nTapi terdapat masalah lain, jumlah pin GPIO pada MCU sangatlah terbatas. Beberapa MCU bahkan hanya memiliki 6 GPIO. Atau, meskipun jumlah pin yang dimiliki melimpah, kita tidak tahu pada update versi selanjutnya akan membutuhkan berapa banyak pin.\nPada kasus kita, ATMega328P sebenarnya memiliki pin yang cukup untuk menangani 8 LED dengan port yang sama. But, let\u0026rsquo;s do it anyway.\nShift Register # Kata \u0026ldquo;register\u0026rdquo; pada shift register secara konsep sama saja seperti register yang ada pada MCU. Register is register. Yang membedakan adalah kata \u0026ldquo;shift\u0026rdquo; (geser). Jadi, shift register adalah salah satu jenis register yang bisa menggeser data di dalamnya dari bit 0 ke bit 1, bit 1 ke bit 2, dan seterusnya ketika diberi sinyal clock.\nDi dalam MCU juga terdapat internal shift register, tapi kali ini kita akan membahas tentang external shift register dalam bentuk Integrated Circuit (IC). Karena ini eksternal, satu-satunya cara untuk memanipulasi register adalah dengan mengirimkan sinyal elektrik HIGH dan LOW. Alih-alih melakukan assignment seperti PORTB = 0x3F; pada program MCU.\nTerdapat dua jenis shift register: Serial In Parallel Out (SIPO), dan Parallel In Serial Out (PISO). Yang akan kita gunakan adalah SIPO karena kita ingin mengurangi penggunaan pin MCU.\nCatatan: Mulai sekarang sampai blog ini selesai, SR berarti Shift Register. Perlu diingat bahwa terdapat makna lain dari SR.\nIC SN74HC595 # Overview # Ilustrasi shift register, sumber lastminuteengineers.com 74HC595 adalah Integrated Circuit yang berguna untuk mengubah input serial menjadi output paralel (SIPO) dengan kapasitas maksimal 8-bit. Di dalamnya, terdapat dua macam register:\nshift register berguna sebagai \u0026ldquo;antrean\u0026rdquo; data masuk, storage register (disebut juga latch) berguna untuk menyimpan data dari shift register dan diteruskan ke pin output. Data shift register hanya akan disimpan jika pin RCLK (disebut juga latch) diberi perubahan sinyal dari LOW ke HIGH. Pin Descriptions # Pinout SNx4HC595, diambil dari datasheet Texas Instruments (TI). Perlu dicatat bahwa garis di atas pin OE dan RCLK memiliki Acrive Low, pin tersebut akan aktif jika dihubungkan ke ground. Pin Number Pin Name Description 15,1-7 Qa-Qh Parallel Output, diambil dari storage register. 8 GND Ground Pin. 9 Qh' Serial Output untuk merangkai 2 shift register atau lebih (kita abaikan di blog ini). 10 SRCLR Shift Register Clear, aktif ketika terhubung ground. 11 SRCLK Shift Register Clock, akan menggeser data di dalam shift register jika pin ini diberi sinyal dari LOW ke HIGH (rising edge). 12 RCLK Register Clock, saat diberi rising edge data shift register akan disalin ke storage register, sehingga mengubah output. 13 OE Output Enable, aktif ketika terhubung ke ground 14 SER Serial data, jalur masuk data serial. 16 VCC Suplai tegangan dari -0.5V sampai dengan 7V. Functional Characteristics # Tabel mode fungsi SNx4HC595, diambil dari datasheet TI. Untuk memahami tabel di atas, berikut beberapa penjelasan untuk masing-masing jenis input:\nX: Don\u0026rsquo;t care, tidak peduli input yang diberikan, H: HIGH, L: Low, ↑: Rising edge, ketika sinyal berubah dari LOW ke HIGH. Pada tabel fungsi, perubahan data dipicu oleh sinyal clock. Yang diperhatikan bukan sinyal HIGH atau LOW, tetapi transisi dari LOW ke HIGH (rising edge). ss Berikut adalah penjelasan masing-masing mode:\nFungsi 1 dan 2, untuk mengaktifkan pin output (Qa-Qh), pin OE harus disambungkan ke ground. Fungsi 3, kita perlu menghubungkan pin SRCLR ke VCC agar SR tidak di-clear. Fungsi 4, ketika SER bernilai LOW, SRCLR HIGH, dan memberi SRCLK sinyal clock: SR akan bergeser dan bit pertama akan bernilai 0. Fungsi 5, Sama seperti sebelumnya, namun SER bernilai HIGH sehingga SR bergeser dan bit pertama bernilai 1. Fungsi 6, ketika RCLK diberi sinyal clock (rising edge), data di dalam SR akan disalin ke storage register. Jadi, koneksi ke MCU yang perlu ditentukan adalah untuk pin SER, SRCLK, dan RCLK. Sedangkan untuk pin output, masing-masing pin dihubungkan ke katoda LED. Untuk pin lain, OE dihubungkan ke ground, dan SRCLR dihubungkan ke VCC.\nNomenclature of the 7400 series IC (trivia) # IC 74HC595 memiliki makna dalam penamaannya. Untuk deskripsi lebih detail Anda dapat meninjau laman Wikipedia berikut: 7400-series Integrated Circuits. Berikut adalah ringkasannya:\nKode 74 di depan merepresentasikan temperatur operasinya: HC adalah singkatan dari Highspeed CMOS, ini adalah kode family line. Terdapat banyak family line lain seperti L (Low Power), C (CMOS), F (Fast), dan masih banyak lagi. Untuk lebih detailnya silakan baca di sini. Sedangkan 595 adalah kode subfamily. Banyak subfamily lain seperti 165 (SIPO SR), 00 (Quad AND Gate), 114 (Dual J-K Flip-Flop), dsb. IC 7400 series ini didesain oleh perusahaan asal Amerika, Texas Instruments. Namun, perusahaan lain memiliki lisensi untuk memproduksi seri ini. Sehingga, diberikan prefiks untuk memberi keterangan perusahaan yang memproduksinya: Interrupts # A Brief Description # Interrupt adalah salah satu fungs dasar pada mikrokontroler yang berguna untuk menginterupsi program utama untuk melakukan proses lain yang lebih penting. Secara teknis, interrupt adalah sinyal yang menginformasikan CPU agar menghentikan apapun yang sedang dilakukan untuk sementara waktu. Setelah itu, Interrupt Service Routine (ISR) akan dijalankan. ISR umumnya ditulis dalam bentuk routine/fungsi. Kemudian, CPU akan kembali melanjutkan proses yang sebelumnya diinterupsi.\nBlocking Process # Pertanyaannya, kenapa perlu menggunakan interrupt? Apakah tidak cukup menggunakan if di dalam main loop? Untuk menjawabnya, kita perlu mengingat bahwa sebuah CPU hanya bisa melakukan satu tugas dalam satu waktu. Sementara itu, proses seperti animasi LED adalah proses yang memakan waktu, sebagian besar waktunya digunakan untuk menunggu beberapa ratus ms agar kita dapat melihat animasinya.\nMisalkan kita menambahkan tombol \u0026lsquo;previous\u0026rsquo;, \u0026rsquo;next\u0026rsquo;, dan \u0026lsquo;restart\u0026rsquo; yang berguna untuk mengontrol animasi mana yang diputar. Tanpa interrupt, jika salah satu tombol ditekan maka tombol itu akan diabakan selama animasi sedang berjalan.\nDengan interrupt, kita bisa menginterupsi di tengah-tengah proses animasi. Kemudian di dalam ISR, ditentukan animasi mana yang akan dimainkan selanjutnya. Setelah itu, ISR akan kembali ke proses yang diinterupsi. Bedanya, kali ini fungsi tersebut akan dihentikan paksa sehingga iterasi main loop juga akan dihentikan paksa.\nInterrupts in ATMega328P # Pada ATMega328P terdapat beberapa macam interrupt, masing-masing memiliki alamat ISR-nya sendiri. Macam sumber interrupt, RESET adalah prioritas tertinggi. Diambil dari datasheet ATMega328P. Sebagai contoh, ketika tombol dengan konfigurasi pull-up resistor ditekan, kondisi pin terkait akan berubah. Maka, untuk menerapkan interrupt, digunakan jenis Pin Change Interrupt (PCINT). Terdapat 3 PCINT (PCINT0-PCINT2), PCINT0 serta PCINT 2 masing-masing menangani 8 pin, dan PCINT1 menangani 7 pin.\nUntuk menggunakan fitur interrupt, sertakan library \u0026lt;avr/interrupt.h\u0026gt;. Secara default interrupt tidak aktif, untuk mengaktifkan interrupt global, pangggil fungsi sei(). Selanjutnya, untuk mengaktifkan interrupt vector spesifik, register interrupt terkait perlu dimanipulasi.\nEIMSK |= (1 \u0026lt;\u0026lt; INT1); sei(); Ekspresi di atas akan memodifikasi EIMSK (External Interrupt Mask Register), mengubah 0 menjadi 1 pada bit INT1. Sehingga interrupt vector INT1 menjadi aktif. Pemanggilan fungsi sei() akan mengaktifkan interrupt secara global.\nKetika terdapat sinyal interrupt INT1 diciptakan, MCU akan segera menjalankan ISR yang sudah didefinisikan:\nISR (INT1_vect) { // isr tasks } ISR dapat diinterupsi oleh interrupt vector yang memiliki prioritas lebih tinggi. Contoh, INT1 dapat diinterupsi oleh INT0 dan RESET.\nProses di dalam ISR sebaiknya dibuat seringkas mungkin. Salah satu cara untuk mempersingkatnya adalah menggunakan variable sebagai flag. Ketika sinyal interrupt diberikan, ISR mengisi flag dengan nilai true. Flag tersebut akan dievaluasi menggunakan control-flow sebelum mengeksekusi suatu proses.\nPutting it All Together # Writing Bytes to the Shift Register # Sebuah LED dapat direpresentasikan sebagai satu bit, delapan LED direpresentasikan menjadi delapan bit atau satu byte. Delapan LED tersebut selanjutnya dihubungkan ke output parallel IC shift register, SN74HC595. Sekarang, kita perlu mencari cara untuk mengirimkan data secara serial ke dalam IC tersebut.\nDengan mengabaikan pin-pin output dan pin lain yang terhubung ke ground atau VCC, berikut adalah pin yang tersisa dan perlu dihubungkan ke ATMega328P:\nSRCLK (11) ke PD0 (2), RCLK (12) ke PD1 (3), dan SER (14) ke PD2 (4). Pin-pin di atas digunakan dalam fungsi-fungsi primer yang melakukan: bit shifting, trigger SR clock, latch SR ke output.\n*Catatan: Nomor pin SN74HC595 mengacu package DIP-16, dan ATMega328P DIP-28\n#define SER PD0 #define R_CLK PD1 #define SR_CLK PD2 void tick(void) { PORTD |= (1 \u0026lt;\u0026lt; SR_CLK); _delay_ms(1); PORTD \u0026amp;= (~(1 \u0026lt;\u0026lt; SR_CLK)); } Ketika routine tick() dieksekusi, data shift register akan digeser dengan nilai bit ke-0 mengikuti nilai SER atau PD0 pada saat fungsi dieksekusi. Hal ini sesuai dengan karakteristik SR pada datasheet yang sudah kita bahas.\nvoid shift_bit(bool bit) { if (bit) PORTD |= (1 \u0026lt;\u0026lt; SER); else PORTD \u0026amp;= (~(1 \u0026lt;\u0026lt; SER)); tick(); } Fungsi shift_bit(bool bit) menerima boolean sebagai parameter. Boolean tersebut dijadikan sebagai nilai PD0. Setelah nilai PD0 diubah, fungsi tick() dipanggil sehingga bit ke-0 pada SR ditentukan oleh parameter bit.\nbool latch(void) { if (restart_requested) { restart_requested = false; return false; } PORTD |= (1 \u0026lt;\u0026lt; R_CLK); _delay_ms(1); PORTD \u0026amp;= (~(1 \u0026lt;\u0026lt; R_CLK)); return true; } Fokus ke bawah terlebih dahulu, fungsi latch() akan menyalakan R_CLK atau PD1 selama 1ms. Sesuai datasheet, high pada RCLK akan menyalin data pada SR ke storage register yang menyimpan nilai output.\nKembali ke atas. Di dalam fungsi latch(), restart_requested yang merupakan variable flag akan diperiksa. Jika bernilai true, flag tersebut akan dikembalikan ke nilai defaultnya. Setelah itu menghentikan eksekusi fungsi latch() dengan return false;.\nProses serupa terjadi secara bertumpuk/bersarang, fungsi yang memanggil latch() dan mendapatkan nilai false akan mengakhiri dirinya dengan mengembalikan nilai false. Dan seterusnya.\nSehingga ketika sinyal interrupt diberikan, semua proses secara instan akan terhenti dan memulai ulang main-loop untuk memulai animasi sebelumnya, selanjutnya, atau memulai ulang animasi saat ini.\nThe Animation # Interrupt for Interface # #include \u0026lt;avr/interrupt.h\u0026gt; int main() { PCICR |= (1 \u0026lt;\u0026lt; PCIE2); PCMSK2 |= (1 \u0026lt;\u0026lt; PCINT21) | (1 \u0026lt;\u0026lt; PCINT22) | (1 \u0026lt;\u0026lt; PCINT23); sei(); while (1) { // main loop program here } } Untuk mendefinisikan program dengan interrupt, diperlukan library \u0026lt;avr/interrupt.h\u0026gt;. Selanjutnya, terdapat 2 register yang perlu ditangani:\nPCICR (Pin Change Interrupt Control Register) Result # Conclusion # References and Further Reading # Foot Notes # Blog pertama pada seri ini ditulis dalam Bahasa Inggris dengan struktur yang tidak konkrit dan grammar yang kacau serta canggung. Blog tersebut juga tidak memberikan contoh kode yang cukup. Saya memutuskan untuk pindah ke Bahasa Indonesia karena target audiens yang lebih mudah diraih adalah audiens lokal. Pembenaran ketiga, bahwasanya jumlah blog teknis yang ditulis dalam Bahasa Indonesia kalah jauh dibandingkan Bahasa Inggris. Sebelumnya, saya sudah mencoba SN74HC595 tanpa MCU, hanya push button dan led. Hasilnya tidak bisa diprediksi. Hal ini terjadi karena push button akan memberikan sinyal yang \u0026ldquo;bouncing\u0026rdquo; (naik turun dari HIGH ke LOW) ketika ditekan. Walaupun bounce tersebut terjadi sangat cepat, namun IC famili HC (High Speed CMOS) sangat sensitif terhadap bouncing. Opsi selain menggunakan MCU adalah dengan menambahkan debouncing circuit, atau menggunakan IC 74HCS595. HCS, High Speed CMOS Schotticky Diode, IC tersebut menambahkan hysteresis sehingga dapat mengabaikan sinyal bouncing lebih dulu sebelum merespon. ","date":"28 December 2025","externalUrl":null,"permalink":"/posts/avr/01-shift-register/","section":"Posts","summary":"","title":"Animating LEDs with Shift Register","type":"posts"},{"content":"","date":"28 December 2025","externalUrl":null,"permalink":"/series/avr/","section":"Series","summary":"","title":"AVR","type":"series"},{"content":"","date":"28 December 2025","externalUrl":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","date":"28 December 2025","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":" For the past few months, I’ve been dabbling in some low-level programming. Was focused with the C language. The C Programming Language (Second Edition) by Kernighan \u0026amp; Ritchie is my reference and guide book. That book is the \u0026ldquo;Holy Bible\u0026rdquo; of C; it packs all the essential knowledge into less than 300 pages, whereas most technical books take more than 400. Later on, at late November, I also started working with bare-metal AVR.\nThis series documents my journey diving into low-level version of Arduino (ATMega328P).\nBare Metal AVR # What is it? Bare Metal means running software directly on physical computer hardware without an excessive abstraction layer. AVR is a computer architecture for ATmega and ATTiny microcontrollers. The MCU that I use is the ATMega328P, the one used by the Arduino UNO Development Board.\nI simply unplugged that chip from the Arduino Dev Board and ran my code directly on that chip. The ATMega328P can be programmed using a programmer, which is quite of a hurdle to do.\nPict. 1: USBASP Programmer, the one that I use. Pict. 2: ATMega328P 28 pin DIP Pinout. Blue-highlighted text is connected to USBASP pinouts using jumper wires. Arduino Works Perfectly Fine, Why All These Hurdles? # Well, first things first, the Arduino Development Board is a quick prototyping board that speeds up development. That’s why you’ll never see any device in the big electronic market that uses the Arduino Dev Board. It’s meant for development, not production.\nArduino run upon an Microcontroller Unit (MCU), which is the ATMega328P. There are tons of MCU families out there; STM32, PIC, MSP, Renesas, and AVR are the most commonly used MCUs in the market.\nSecond, it runs faster. By stripping off the Arduino abstractions, we can write a plain C program and flash it to the chip. Here’s a comparison between Arduino .ino code and its C equivalent:\nThe Arduino Code:\nvoid setup() { // setup here } void loop() { // the code that loops forever } C Code:\nint main() { // setup here while (1) { // the code that loops forever } } You see, Arduino is just an abstraction layer. Which is good if you want high portability and fast prototyping. But the abstraction itself is slow in terms of performance.\nIt won\u0026rsquo;t matter if you just blink an LED every one second, but if you\u0026rsquo;re doing something that requires you to have precise timing, even a millisecond matters.\nThose two are my reasons. The third is my motive: to challenge myself.\nRegisters # Just like any other computer, an MCU contains a CPU (Central Processing Unit). Inside it, there’s a small high-speed memory called registers that hold data temporarily during the execution cycle of the program. These registers control how the GPIO, ADC, Timers, and any other peripherals should behave.\nThe structure of each register is usually specified in the corresponding MCU Datasheet or Reference Manual. For example, if we want pin 15 to blink an LED, we have to dive into the datasheet:\nPict 3: ATMega328P 28 pin DIP Pinout. Source: ATMega328P Datasheet. Pin 15 is identified as PB1. Each pin port has three registers: DDRx, PORTx, and PINx (x can be B, C, or D). Since we just want to output things, we can ignore the PINx register. DDRB: Data Direction B Register\nThis register handles the direction of data. As you can see below, there are 8 bits of data. Each bit corresponds to a single pin (PB0-PB7). Default value is 0, which means it will act as input. Otherwise, it will act as an output. Pict 4: DDRB Register. Source: ATMega328P Datasheet. To set PB1 as an output, we should set bit-1 at the DDRB register as 1. PORTB Data Register\nThe PORTB register handles what signal each pin should send. It can be either HIGH or LOW, 1 or 0. To turn on the LED, simply set 1 to bit-1 at the PORTB register. Pict 5: PORTB Data Register. Source: ATMega328P Datasheet. Bitwise Operators # To handle all these bit-by-bit operations I had to equip myself with the right tool: bit-wise operators. This operator simply gives me bit-wise manipulation techniques:\nClearing a bit on a register REG \u0026amp;= (~(1\u0026lt;\u0026lt;TARGET_BIT)); Setting a bit REG |= (1\u0026lt;\u0026lt;TARGET_BIT); Rotating a bit ROTATED = (REG\u0026lt;\u0026lt;3) | (REG\u0026gt;\u0026gt;(8-3)) Extracting a bit from registers DATA = (REG \u0026gt;\u0026gt; 4) Many other operations Input # There are many ways to receive an input signal. You can receive it from some communication channel, sensor, or a simpler one, like a switch button and a potentiometer.\nFor handling digital input, it’s quite easy. What we do is the opposite of sending an output signal. We read the PORTx register.\nBut an analog signal is slightly more complicated than that. Firstly you have to do the conversion from analog to digital signal. In doing so, there are some registers that you should take care of: DDRx, PORTx, PINx, ADMUX, ADCSRA. And, if you manage to start the ADC process, the MCUs will store the output into two separate registers, ADCL and ADCH. They’re separated because ATMega328P have 10 bits ADC, while a register can only store up to 8 bits.\nFirst Project: Morse Code # I have done some easy things with this low-level stuff. But I wouldn’t call them projects; exercise is the perfect description for that.\nMy first project is to encode a string into visible and audible Morse code (LEDs and buzzer). The code and schematics are available on my repo, see below. You can watch it on YouTube if you want:\nJust like any other system, here\u0026rsquo;s how it works from input, process, to output:\nThe input. My program will accept two digital inputs and one analog input.\nThe analog input is a signal from a potentiometer. It reads the voltage from 0v to 5v. The digital inputs are simply two switches, pull-up and pull-down. It is responsible for telling the MCU when to send the Morse code. The pull-up one will make the CPU send a “Hello World” in Morse code. The other one will send the value of that analog input. The process. Some of the main processes are:\n26 letters of alphabets -\u0026gt; Morse code. It only uses switch case, and call two routines: dot(), dash(). This part is the most bad-looking code in my program, but at least it works. ADC. This process will start right after the pull-down switch is triggered. The output will be stored in an int and converted to a string. Later on, it will be sent to the output. The output. There are two types of Morse code that will be sent by this program:\n“Hello World” The value of that analog input ranges from 0 (represents 0v) to 1023 (represents 5v). For the ‘how’ Morse code is being sent, there are three LEDs (RGB) and a buzzer. Like I said, visible and audible. Each one indicates a different meaning:\nRed LED blinks briefly = dot. Green LED blinks shortly = dash. Blue LED = separation. Separate words or indicate the starting point. Conclusion # The shift from high-level to low-level gives me some kind of reward that I can\u0026rsquo;t explain by mere words. I\u0026rsquo;ll try.\nIt gives me a broader yet deeper picture of how things work on a system. Stripping down the abstractions somehow makes me appreciate more about the everyday device around me. How such a simple thing has been engineered multiple times through trials and errors.\nIn simple terms, I am grateful for abstraction.\nNext interesting things # Thank you for spending your time reading all these yaps. It\u0026rsquo;s an interesting for me to drive a device without the use of external excessive library. Especially for learning things, I\u0026rsquo;d rather write my own driver. Here are things that I might do later:\nDriving LED with Shift Register (74HC595) Driving 7 Segment Display with MAX7219 Driving 8x8 Matrix LED Display with MAX7219 Bit banging the 16x02 LCD to show text Bit banging in rhytm to control WS2812B addressable RGB LED Links # GitHub: vfadlan/avr-exp/04-potensio-adc ATMega328P Datasheet ","date":"22 December 2025","externalUrl":null,"permalink":"/posts/avr/00-hello/","section":"Posts","summary":"","title":"Hello, Bare Metal AVR.","type":"posts"},{"content":"It’s been a long time since I published my first blog; it was more than 6 months ago. Now here it is, I set up my own blog on a new, completely free platform.\nThe Shift # As of November 6th, 2025, the domain name of fadlanabduh.com has expired. I didn’t have enough money to renew it, and now it costs me more than $110+ USD for the late renewal fee (fine).\nPreviously, I used Google Sites + blogspot for all my websites. Now that I don’t have a domain, using them is not that good for SEO.\nSo, I switched to GitHub Pages for my main web and blogging platform.\nStatic Site Generator (SSG) # I use this thing called Hugo SSG, and I use some open-source template for the sake of time. Here’s basically how it works:\nI set up the site: template, configs, GitHub repo, and pages, etc. Write content in forms of Markdown inside the content/ directory. Push it to a GitHub Repository. Github Action format every .md (markdown) file inside content/ to some .html Those .html will be accessible via GitHub Pages. What’s Coming Next # I don’t know what I’m going to post on this new blogsite that I set up overnight. Maybe this blog is simply just a (rushed) realization of my 2025 goal; it might (or might not) continue. I can only promise one thing from this blogsite: I post more often here compared to other social media (Instagram, Facebook, etc).\n","date":"21 December 2025","externalUrl":null,"permalink":"/posts/new-blogsite/","section":"Posts","summary":"","title":"New Blogsite","type":"posts"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"}]