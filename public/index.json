
[{"content":"This blog is a record of things I break, fix, and understand better in software, electronics, and embedded systems.\nAs a bonus, I might share some other things too.\n","date":"20 January 2026","externalUrl":null,"permalink":"/","section":"","summary":"","title":"","type":"page"},{"content":"","date":"20 January 2026","externalUrl":null,"permalink":"/series/avr/","section":"Series","summary":"","title":"AVR","type":"series"},{"content":"","date":"20 January 2026","externalUrl":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","date":"20 January 2026","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":" Table of Contents # Intro - Objective Timer\na. ↳ Do The Math\nb. ↳ Registers\nc. ↳ Button Debouncing MAX7219 LED Display Driver\na. ↳ Overview\nb. ↳ Serial Peripheral Interface (SPI) Protocol\nc. ↳ Registers Map\nd. ↳ Daisy Chaining Show Something\na. ↳ 8 Digit 7-Segment LED\nb. ↳ 8x8 LED Matrix Result Conclusion References and Further Reading Intro - Objective # Pada blog teknikal kali kini, kita akan mencoba menjadikan mikrokontroler ATMega328P sebagai otak dari jam digital. Jam digital akan ditampilkan dalam format 8 digit: HH.MM.SS.cc dengan c adalah centiseconds.\nUntuk menampilkan waktu, digunakan modul display 7 segment dengan MAX7219 sebagai drivernya. Selain itu, digunakan pula display matrix 8x8 dengan driver yang sama untuk tantangan semata.\nMatrix 8x8 akan menampilkan beberapa emoji/karakter, angka, huruf kapital, dan huruf kecil. Untuk mengganti tampilan, digunakan dua tombol: prev dan next.\nPada jam digital, ditambahkan mekanisme \u0026ldquo;hold\u0026rdquo; yang akan menghentikan waktu (display) selama tombol masih ditekan.\nProgram akan dibahas secara runtut dari program utama timer, debouncing button, hingga interface MAX7219. Kita akan menggunakan beberapa konsep C seperti pointers, reference, dan struct, pastikan Anda telah memahaminya.\nTimer # Secara umum, timer adalah periferal pada mikrokontroler yang berguna untuk menghitung sinyal clock. Timer dSecara umum, timer adalah periferal pada mikrokontroler yang berguna untuk menghitung sinyal clock. Timer dapat dikonfigurasi sedemikian rupa, sehingga perhitungannya dapat digunakan untuk mengukur waktu, delay, dan lain lain. apat dikonfigurasi sedemikian rupa, sehingga perhitungannya dapat digunakan untuk mengukur waktu, delay, dan lain lain.\nTimer bekerja dengan melakukan increment/decrement nilai register setiap beberapa interval. Batas bilangan dan interval dapat dikonfigurasi.\nMikrokontroler ATMega328P dibekali dengan tiga buah timer: timer0 8-bit, timer1 16-bit, dan timer2 8-bit. Kita akan menggunakan timer1 16-bit untuk mengukur waktu dan melakukan button debouncing.\nTimer ini memiliki beberapa mode utama: normal, pwm (pulse width modulation), ctc (clear timer compare match). Pada mode ini, timer akan melakukan increment pada register TCNT1H dan TCNT1L*. Kemudian membandingkan nilai kedua register tersebut dengan register pembanding yang kita konfigurasi.\nKetika nilainya cocok (match), register TCINT1H dan TCINT1L akan direset ke nilai 0. Jika kita mengaktifkan interrupt, ISR akan dijalankan.\n*Catatan: TCNTH untuk byte 8-15 dan TCNT1L untuk byte 0-7.\nDo The Math # Unit waktu terkecil pada jam yang akan dibuat adalah 1 centisecond: $$ 1\\text{ s} = 100\\text{ cs} = 1,000\\text{ ms} = 1,000,000\\text{ μs} = 1,000,000,000\\text{ ns} $$Unit centiseconds dijadikan sebagai variable global volatile yang nilainya diincrement setiap 10ms oleh ISR timer 1. Kita perlu mengkonfigurasi timer1 untuk menjalankan ISR setiap 10ms. Sebelum itu, kita hitung terlebih dahulu berapa lama durasi 1 clock cycle. $$ f_{CPU} = 16\\text{ MHz} = 16,000,000\\text{ clock cycles/s} $$ $$ T = \\frac{1,000,000,000\\text{ ns}}{16,000,000\\text { ticks}} = 62.5\\text{ ns/cycle} $$ $$ \\frac{10\\text{ ms}}{62.5\\text{ ns}} = \\frac{10,000,000\\text{ ns}}{62.5\\text{ ns}} = 160,000\\text{ clock cycles} $$ Butuh 160.000 clock cycle untuk mencapai durasi 10ms jika frekuensi yang digunakan adalah 16MHz. Angka ini terlalu besar untuk timer1 yang hanya 16-bit, \\(2^{16} = 65,536\\).\nUntuk mengatur frekuensi timer ATMega328P, dapat diterapkan sebuah prescale. Yakni membagi frekuensi CPU dengan suatu bilangan. Pada timer 1, frekuensi dapat dibagi dengan \\(1, 8, 64, 256,\\) atau \\(1,024\\).\nPerlu diingat bahwa prescale pada timer tidak akan memengaruhi frekuensi utama CPU. Untuk kejelasan, tick merepresentasikan 1 clock cycle pada timer, bukan frekuensi utama CPU.\n$$ \\frac{16\\text{ MHz}}{8} = 2\\text{ MHz} = 2,000,000\\text{ ticks/s} = \\frac{2,000,000\\text{ ticks}}{1,000,000,000\\text{ ns}} $$ $$ T_{tick} = \\frac{1,000,000,000\\text{ ns}}{2,000,000\\text { ticks}} = 500\\text{ ns} $$ $$ \\frac{10\\text{ ms}}{500\\text{ ns}} = \\frac{10,000,000\\text{ ns}}{500\\text{ ns}} = 20,000\\text{ ticks} $$Sekarang kita tahu bahwa untuk mencapai 10ms dibutuhkan 20.000 tick timer1, jika frekuensi timer1 dibagi 8. 19.999 (hitung dari 0) akan menjadi nilai pembanding timer1 untuk menjalankan ISR, sehingga ISR dijalankan setiap 10ms.\nRegisters # TCCR1B = (1 \u0026lt;\u0026lt; 3) | 0b010; (1 \u0026lt;\u0026lt; 3) akan mengaktifkan mode CTC dengan nilai OCR1A sebagai nilai pembanding (Table 15-5). Dan | 0b010 akan mengaktifkan prescale 8 (Table 15-6).\nSetelah timer 1 dikonfigurasi, kita masih perlu membandingkan nilai TCINT1 dengan 19999.\nOCR1A atau OCR1B cocok dengan kebutuhan kita. Untuk mengaktifkan interrupt ketika nilai OCR1A dan TCINT1 cocok, register TIMSK harus diubah.\nint main() { // ... TCCR1B = (1 \u0026lt;\u0026lt; 3) | 0b010; // ctc mode, presale 8 (2 MHz) OCR1A = 19999; // 10ms each match TIMSK1 |= (1 \u0026lt;\u0026lt; OCIE1A); // Enable compare match A interrupt // ... } Dengan konfigurasi timer di atas, sinyal interrupt vector TIMER1_COMPA akan dihasilkan setiap 10ms. Di dalam ISR kita dapat melakukan increment variabel centiseconds, dan mengaktifkan flag update_display.\nFlag update_display digunakan agar driver tidak terlalu banyak bekerja. Frekuensi maksimal yang dapat ditanggung IC MAX7219 adalah 800Hz. Dengan update setiap 10ms, maka frekuensinya adalah 100Hz.\nvolatile uint32_t centiseconds = 0; volatile bool count = true; volatile bool update_display = true; ISR (TIMER1_COMPA_vect) { if (count) { centiseconds++; update_display = true; } // ... } Variabel boolean count ditentukan oleh sebuah tombol, ketika ditahan nilainya false. Terdapat dua tombol lain prev dan next, yang berfungsi untuk mengganti tampilan matrix 8x8.\nAlih-alih menggunakan PCINT (Pin Change Interrupt) atau EINT (External Interrupt), kita akan menggunakan ISR yang sudah ada.\nButton Debouncing # Pada program sebelumnya, kita menggunakan _delay_ms(25) di dalam ISR untuk melakukan debouncing pada sebuah tombol. Namun, ISR harus diselesaikan dalam clock cycle seminimal mungkin. Fungsi delay melanggar aturan tersebut.\nGenerally it is never recommended to use a delay routine inside the ISR. ~AVR1200: Using External Interrupts for megaAVR Devices, ATMEL Application Notes\nSebagai alternatif, kita dapat menggunakan ISR timer yang sudah kita buat untuk mengecek keadaan tiga tombol setiap 10ms.\n#define BUTTON_COUNT 3 typedef struct { uint8_t *inputreg; uint8_t pin_no; bool last_state; uint8_t delay; bool event; } button_t; volatile button_t hold; // PD2 volatile button_t next; // PD6 volatile button_t prev; // PD7 volatile button_t *buttons[BUTTON_COUNT] = { \u0026amp;hold, \u0026amp;next, \u0026amp;prev }; button_t init_button(uint8_t *inputreg, char pin_no) { button_t temp; temp.inputreg = inputreg; temp.pin_no = pin_no; temp.last_state = ((*inputreg) \u0026gt;\u0026gt; pin_no) \u0026amp; 1; temp.delay = 0; temp.event = false; return temp; } Karena ketiga tombol memiliki karakteristik/parameter yang sama, kita dapat memanfaatkan struct.\nArray *buttons akan diiterasi di dalam ISR. Masing-masing elemen array tersebut menunjuk ke alamat memori sebuah struct button_t.\nint main() { //... hold = init_button(\u0026amp;PIND, PD2); next = init_button(\u0026amp;PIND, PD6); prev = init_button(\u0026amp;PIND, PD7); PORTD = (1 \u0026lt;\u0026lt; hold.pin_no) | (1 \u0026lt;\u0026lt; next.pin_no) | (1 \u0026lt;\u0026lt; prev.pin_no); //... } Pemanggilan fungsi init_button di dalam main akan menginisialisasi struct button_t. Ketiga tombol di atas merupakan pull-up button, sehingga nilai last_state adalah 1, dan kita perlu memberi nilai HIGH pada PORTD.\nKarena alamat ketiga variabel di atas disimpan dalam sebuah array, kita dapat menggunakan for loop di dalam ISR untuk mengecek keadaan setiap tombol:\n#define DEBOUNCE_DELAY 3 ISR (TIMER1_COMPA_vect) { if (count) { centiseconds++; update_display = true; } for (int i=0; i\u0026lt;BUTTON_COUNT; i++) { bool current_state = (*(buttons[i]-\u0026gt;inputreg) \u0026gt;\u0026gt; buttons[i]-\u0026gt;pin_no) \u0026amp; 1; if (current_state != buttons[i]-\u0026gt;last_state) { if (buttons[i]-\u0026gt;delay\u0026gt;=DEBOUNCE_DELAY) { buttons[i]-\u0026gt;event = true; buttons[i]-\u0026gt;last_state = current_state; buttons[i]-\u0026gt;delay = 0; } else { buttons[i]-\u0026gt;delay++; } update_display = true; } else { buttons[i]-\u0026gt;delay = 0; } } } Di setiap iterasinya, jika kondisi tombol saat ini berbeda dengan kondisi terakhir, nilai member delay akan di-increment. Ini akan terjadi sebanyak tiga kali setiap ISR dijalankan, yakni setiap 10ms. Dengan begitu, durasi total debounce adalah 30ms.\nSetelah nilai delay \u0026gt;= 3, flag event akan diaktifkan, keadaan terakhir diperbarui, dan delay diulang ke 0. Flag event nantinya digunakan pada main loop untuk menjalankan aksi yang diperlukan.\nextern uint8_t IMAGES_LEN; volatile int c = 0; int main() { // ... while (1) { // ... if (hold.event) { if ((*(hold.inputreg) \u0026gt;\u0026gt; hold.pin_no) \u0026amp; 1) { count = true; } else { count = false; } hold.event = false; } if (next.event) { if (!((*(next.inputreg) \u0026gt;\u0026gt; next.pin_no) \u0026amp; 1)) { if (c==(IMAGES_LEN-1)) { c = 0; } else { c++; } } next.event = false; } if (prev.event) { if (!((*(prev.inputreg) \u0026gt;\u0026gt; prev.pin_no) \u0026amp; 1)) { if (c) { c--; } else { c = IMAGES_LEN-1; } } prev.event = false; } } } Tidak lupa, setelah aksi, member event dikembalikan ke nilai false.\nSistem debounce di atas tidak menggunakan fungsi blocking _delay_ms yang akan memblokir semua proses dalam periode tertentu. Alih-alih, ISR timer yang sudah dikonfigurasi digunakan untuk mengecek keadaan masing-masing tombol dan melakukan delay non-blocking. Karena merupakan proses non-blocking, display waktu tidak akan terhambat oleh proses debounce.\nMAX7219 LED Display Driver # Modul display 7 segment dan 8x8 matrix dengan driver MAX7219. The MAX7219/MAX7221 are compact, serial input/ output common-cathode display drivers that interface microprocessors (μPs) to 7-segment numeric LED displays of up to 8 digits, bar-graph displays, or 64 individual LEDs. Included on-chip are a BCD code-B decoder, multiplex scan circuitry, segment and digit drivers, and an 8x8 static RAM that stores each digit. Only one external resistor is required to set the segment current for all LEDs. ~MAX7219/MAX7221 Datasheet\nOverview # Kita akan menggunakan modul 7-segment untuk menampilkan waktu, dan modul 8x8 matrix untuk menampilkan karakter.\nPada modul 7-segment 8 digit, terdapat 8 LED untuk masing-masing digit (termasuk titik), \\(8 × 8 = 64\\). Modul display 8x8 matrix juga memiliki jumlah LED yang sama, 64. Total, terdapat 128 LED yang perlu dikendalikan. Jumlah yang terlalu banyak jika hanya dikendalikan oleh ATMega328P.\nOleh karena itu, IC MAX7219 digunakan sebagai display driver. Satu unit IC ini dapat mengendalikan 8 digit 7 segment, atau 64 LED. IC ini bekerja menggunakan teknik multiplexing. Yakni mengendalikan satu digit dalam satu waktu, dan beralih ke digit lainnya dengan sangat cepat sehingga tercipta ilusi bahwa semua digit tampil secara bersamaan.\nScanning by columns at fast-enough frequencies cause the number \u0026lsquo;1.234\u0026rsquo; to appear static, due to the persistence of vision optical illusion. Source: Wikipedia.org Untuk alasan kemudahan, kita menggunakan modul display yang sudah tertanam IC MAX7219.\nPinout Description # Display Module Pinout Karena kedua modul menggunakan IC yang sama, pinout kedua modul juga sama. Di sebelah kiri adalah in, sebalah kanan out.\nPin DIN dan CLK digunakan untuk protokol komunikasi Serial Peripheral Interface (SPI). Pin CS akan memperbarui display ketika diberi sinyal rising edge.\nSinyal output di sebelah kanan berguna untuk merantai (daisy chaining) beberapa modul display. Contoh, DOUT dari modul A disambungkan ke DIN dari modul B. Dengan ini, jumlah pin yang terhubung ke MCU tetaplah sama.\nModul yang dirantai tidak harus memiliki jenis tampilan yang seragam, selama IC yang digunakan sama, MAX7219. Pada kasus kita, modul 7-segment 8 digit akan dihubungkan ke MCU, dan DOUT dari modul tersebut dirantai ke modul 8x8 matrix.\nSerial Peripheral Interface (SPI) Protocol # SPI Master-Slave Interconnection Serial Peripheral Interface (SPI) adalah protokol komunikasi serial synchronous, yang berarti mengirimkan data secara serial dengan clock yang tersinkronisasi. Protokol ini menggunakan arsitektur master-slave seperti yang terlihat pada gambar di atas. Dalam hal ini, ATMega328P berperan sebagai master, dan dua modul MAX7219 sebagai slave.\nDapat diperhatikan pada sisi master dan slave, masing-masing terdapat 8-bit shift register. Pada blog sebelumnya, kita mencoba \u0026ldquo;mengisi\u0026rdquo; shift register dengan menyala-matikan tiga buah pin: SER, SCLK, RCLK.\nKali ini, kita tidak perlu mengisi shift register master secara manual. Mikrokontroler ATMega328P sudah dilengkapi dengan peripheral SPI. Sehingga kita cukup mengkonfigurasi periferal tersebut satu kali, dan mengisi shift register seperti mengisi variabel.\nPerlu dicatat bahwa protokol SPI memiliki variasi yang cukup banyak, sehingga konfigurasi perangkat satu dengan lainnya mungkin berbeda. Secara umum, terdapat empat jalur utama pada protokol SPI:\nKode Kepanjangan Arah Deskripsi SCK Serial Clock Master -\u0026gt; Slave Dikirim oleh master untuk mensinkronkan transfer data MOSI Master Out Slave In Master -\u0026gt; Slave Data dari master ke slave MISO Master In Slave Out Slave -\u0026gt; Master Data dari slave ke master SS/CS Slave Select / Chip Select Master -\u0026gt; Slave Untuk memilih slave mana yang aktif IC MAX7219 tidak memiliki pin SS/CS, hanya ada pin LOAD. Data yang disimpan pada shift register MAX7219 akan di-latch ketika LOAD diberi sinyal rising edge. Ini membuat MAX7219 tidak bisa dianggap sepenuhnya \u0026ldquo;SPI\u0026rdquo;. Namun, kita masih bisa menangani pin LOAD secara manual.\nBerhubung MAX7219 adalah modul driver display (output), pin MISO tidak digunakan di sini. Pada jalur MOSI, bit pertama yang dikirim adalah bit paling signifikan (MSB first).\nSPI Control Register SPCR Clock Phase SPI2x, SPR1, SPR0 MAX7219 Timing Diagram Terdapat banyak opsi konfigurasi yang dapat diubah, kita akan mengikuti datasheet MAX7219 dan kebutuhan untuk konfigurasi SPI:\nSPIE = 0, tidak butuh. SPE = 1, perlu dinyalakan untuk menggunakan SPI. DORD = 0, MSB first. MSTR = 1, MCU sebagai master. CPOL = 0, idle low sesuai timing diagram. CPHA = 0, sample diambil pada rising/leading edge clock. SPR1:0 = 0, MAX7219 mampu menghandle SCK sampai 10 MHz. SPI2X = 1, 16MHz/2 = 8MHz. Tidak lupa kita perlu mengatur pin SCK, MOSI, dan LOAD sebagai output. Pada ATMega328P, pin SCK = PB5, MOSI = PB3, dan pin LOAD = PB2. Pin LOAD dapat menggunakan pin manapun karena kita mengontrolnya secara manual.\nvoid SPI_init(int sck, int mosi, int load) { PORTB |= (1 \u0026lt;\u0026lt; load); DDRB |= (1 \u0026lt;\u0026lt; sck) | (1 \u0026lt;\u0026lt; mosi) | (1 \u0026lt;\u0026lt; load); SPCR = (1 \u0026lt;\u0026lt; SPE) | (1 \u0026lt;\u0026lt; MSTR); SPSR |= 1; // prescale 2 } void SPI_transmit(uint8_t data) { SPDR = data; while (!(SPSR \u0026amp; (1 \u0026lt;\u0026lt; SPIF))); } Pada fungsi SPI_transmit, assignment ke variabel SPDR akan mengisi shift register internal dan mengirimkan data ke jalur MOSI secara langsung. Ukuran data pada satu kali transmisi adalah 1 byte. Setelah transmisi selesai, bit SPIF pada SPSR akan berubah menjadi 1.\nSPI Data Register Registers Map # MAX7219 Serial Data Format MAX7219 Register Address Map Format data instruksi yang diterima MAX7219 berukuran 2 Byte. Byte paling signifikan berisi alamat register yang akan diubah (D8-D11), byte bawah berisi data yang akan ditulis pada register tersebut.\nSecara default, MAX7219 berada dalam shutdown mode. Untuk keluar dari shutdown mode pada saat inisialisasi, kita perlu mengirim alamat register shutdown 0x0C diikuti dengan mode normal 1. Pada datasheet MAX7219, nilai data masing-masing register dijelaskan dengan sangat lengkap. Saya tidak akan menampilkan semua tabelnya di sini. Kurang lebih berikut adalah deskripsi singkat masing-masing register:\nNo-Op: No Operation, digunakan untuk daisy-chaining. Digit 0-7: Menentukan LED mana saja yang menyala pada tiap-tiap digit. Decode Mode: Untuk mengaktifkan 7-segment decoder pada beberapa digit. Intensity: Mengatur kecerahan dalam skala 0-15. Scan Limit: Menentukan berapa digit yang aktif. Shutdown: Shutdown mode. Display Test: Jika aktif semua LED akan menyala. Daisy Chaining # Dalam melakukan daisy chaining, hal yang perlu diperhatikan adalah cara kita mengirim instruksi. Mengacu pada datasheet, kita perlu menggunakan instruksi No Operation.\nPada satu kali transmisi instruksi, hanya 1 modul yang mendapat instruksi aktif. Modul lainnya akan mendapat instruksi No-Op. Contoh berikut mengeluarkan tiga modul dari mode shutdown:\nKeterangan Modul 1 Modul 2 Modul 3 Transmisi Pertama 0x0C00 0x0 0x0 Transmisi Kedua 0x0 0x0C00 0x0 Transmisi Ketiga 0x0 0x0 0x0C00 Initialization # Untuk melakukan inisialisasi, kita perlu mengetahui terlebih dahulu total modul MAX7219 yang terhubung. Sehingga kita dapat mengirimkan jumlah instruksi No-Op yang tepat.\n// register address #define MAX_TEST 0xF #define MAX_SHUTDOWN 0xC #define MAX_SCAN 0xB #define MAX_INTENSITY 0xA #define MAX_MODE 0x9 volatile uint8_t device_num = 0; void send_instruction(uint16_t instruction, uint8_t load_pin, uint8_t target_id) { PORTB \u0026amp;= (~(1 \u0026lt;\u0026lt; load_pin)); for (int i=0; i\u0026lt;(device_num - 1 - target_id); i++) { SPI_transmit(0x00); SPI_transmit(0x00); } SPI_transmit(instruction \u0026gt;\u0026gt; 8); // address SPI_transmit(instruction \u0026amp; 0xFF); // data for (int i=0; i\u0026lt;target_id; i++) { SPI_transmit(0x00); SPI_transmit(0x00); } PORTB |= (1 \u0026lt;\u0026lt; load_pin); } void display_init(uint8_t decode_mode, uint8_t scan_limit, uint8_t intensity, uint8_t load_pin, uint8_t id, uint8_t total_display) { device_num = total_display; send_instruction((MAX_TEST \u0026lt;\u0026lt; 8), load_pin, id); send_instruction((MAX_SHUTDOWN \u0026lt;\u0026lt; 8), load_pin, id); send_instruction(((MAX_MODE \u0026lt;\u0026lt; 8) | decode_mode), load_pin, id); send_instruction(((MAX_SCAN\u0026lt;\u0026lt; 8) | (scan_limit \u0026amp; 0x7)), load_pin, id); send_instruction(((MAX_INTENSITY\u0026lt;\u0026lt; 8) | (intensity \u0026amp; 0xF)), load_pin, id); send_instruction(((MAX_SHUTDOWN \u0026lt;\u0026lt; 8) | 1), load_pin, id); } Jumlah device MAX7219 didefinisikan sebagai variabel global sehingga dapat diakses oleh kedua fungsi.\nPada fungsi send_instruction, pin load akan menjadi LOW. Setelah itu instruksi No-Op akan dikirimkan sebelum dan/atau sesudah instruksi utama sesuai kebutuhan. Ketika semua instruksi terkirim, pin load kembali ke posisi HIGH sehingga display akan diperbarui.\nRoutine display_init akan mengirimkan serangkaian instruksi untuk menginisialisasi display sesuai argumen yang diberikan: decode_mode, scan_limit, intensity, load_pin, id, total_display.\nShow Something # MAX7219 disertai dengan Code-B Decoder, ini berguna untuk men-decode bilangan biner 4-bit (0-15) pada register digit ke tampilan 7 segment. Ketika diaktifkan, decoder akan menentukan segmen mana saja (A-G) yang akan menyala.\n8 Digit 7-Segment LED # //... #define SCK PB5 #define MOSI PB3 #define LOAD PB2 int main() { //... SPI_init(SCK, MOSI, LOAD); display_init(0xFF, 0x07, 7, LOAD, 0, 2); //... } Modul pertama yang terhubung ke MCU adalah modul 7 segment untuk menampilkan waktu. Pada inisialisasi, 0xFF mengaktifkan decoder untuk semua digit, 0x07 mengatur brightness menjadi 7/15, 0 karena merupakan perangkat pertama, dan total modul ada 2.\nvoid display_codeB(uint8_t digit, uint8_t code, uint8_t load_pin, uint8_t id) { send_instruction((((digit \u0026amp; 0xF) \u0026lt;\u0026lt; 8) | code), load_pin, id); } Rutin display_codeB akan mengirim instruksi ke register beralamat digit, sehingga digit terkait menampilkan nilai code.\nint main() { while(1) { // ... if (update_display) { if (centiseconds \u0026gt;= 8640000) { centiseconds = 0; } cs = centiseconds % 100; remaining_seconds = centiseconds/100; h = remaining_seconds / 3600; m = remaining_seconds / 60 % 60; s = remaining_seconds % 60; // v display_codeB(1, ((cs % 10) | (1 \u0026lt;\u0026lt; 7)), LOAD, 0); display_codeB(2, (cs / 10), LOAD, 0); display_codeB(3, ((s % 10) | (1 \u0026lt;\u0026lt; 7)), LOAD, 0); display_codeB(4, (s / 10), LOAD, 0); display_codeB(5, ((m % 10) | (1 \u0026lt;\u0026lt; 7)), LOAD, 0); display_codeB(6, (m / 10), LOAD, 0); display_codeB(7, ((h % 10) | (1 \u0026lt;\u0026lt; 7)), LOAD, 0); display_codeB(8, (h / 10), LOAD, 0); display_char(c, LOAD, 1); update_display = false; } } } Pada setiap 10ms, nilai masing-masing satuan (jam, menit, sekon, centisekon) akan dihitung. Proses ini berlangsung singkat, jauh lebih singkat dari 160.000 clock cycle (10ms).\n8x8 LED Matrix # Untuk display kedua, kita menggunakan modul 8x8 matrix untuk menampilkan beberapa karakter.\ndisplay_init(0x00, 0x07, 7, LOAD, 1, 2); 0x00 untuk menonaktifkan decoder. Ketika decoder dinonaktifkan, masing-masing register digit akan menentukan satu baris seperti ilustrasi di bawah.\nconst uint8_t EMOJI_NUM = 6; const uint64_t IMAGES[] = { 0x0800080810202418, // 0 ? 0x8142241818244281, // 1 x 0x1818001818181818, // 2 ! 0x040A112040800000, // 3 v 0x00183C7EFFFF6600, // 4 heart emoji 0x3C4299A581A5423C, // 5 smile emoji 0x3C42A59981A5423C, // 6 sad face emoji 0x3C4281BD81A5423C, // 7 flat face emoji 0x3c3c1818181e1c18, // 0 0x7e7e1c3060667e3c, // 1 //... } const uint8_t IMAGES_LEN = sizeof(IMAGES)/8; void display_char(int c, uint8_t load_pin, uint8_t id) { uint64_t image; uint8_t d; image = IMAGES[c]; for (int j=0; j\u0026lt;8; j++) { d = ((image \u0026gt;\u0026gt; (8 * j)) \u0026amp; 0xFF ); send_instruction((((8-j) \u0026lt;\u0026lt; 8) | d), load_pin, id); } } Array IMAGES menyimpan karakter-karakter mulai dari emoji, angka, huruf kapital, dan huruf kecil. Masing-masing elemen berukuran 64-bit, setiap bit-nya menentukan nyala/mati satu buah led pada matrix 8x8. Pada definisi di atas, data disimpan dalam bentuk heksadesimal untuk alasan keringkasan. 2 digit heksadesimal setara dengan 1 byte, 1 baris.\nArray gambar penuh dapat diakses pada repository github: vfadlan/avr-exp/08-max7219-timer.\ndisplay_char(c, LOAD, 1); Pemanggilan fungsi di atas akan menampilkan IMAGES[c] pada modul kedua.\nResult # Conclusion # Dalam menggunakan timer, kita perlu melakukan perhitungan untuk mendapat hasil yang presisi. Bahkan hingga ke level nanosecond.\nSejauh ini, kita menggunakan timer untuk debounce tombol, dan menghitung waktu setiap 10ms. Waktu tersebut ditampilkan ke modul 7-segment 8 digit.\nDisplay 7-segment 8 digit dikendarai oleh IC MAX7219 yang menggunakan SPI sebagai protokol komunikasinya. IC tersebut menangani berbagai macam hal seperti multiplexing, 7-segment decoder, daisy-chaining, dll.\nDengan penggunaan IC MAX7219 sebagai driver eksternal, beban kerja CPU berkurang signifikan. Selain itu, ATMega328P dilengkapi dengan peripheral SPI sehingga dapat meringankan pekerjaan CPU dalam proses komunikasi.\nReferences and Further Reading # GitHub: vfadlan/avr-exp/08-max7219-timer ATMega328P Datasheet [MAX7219 Driver Datasheet] [AVR1200: Using External Interrupts for megaAVR Devices] ","date":"20 January 2026","externalUrl":null,"permalink":"/posts/avr/02-max7219/","section":"Posts","summary":"","title":"Timer and LED Driver","type":"posts"},{"content":" Table of Contents # Intro Shift Register IC SN74HC595\na. ↳Overview\nb. ↳Pin Descriptions\nc. ↳Functional Characteristics Interrupts\na. ↳A Brief Description\nb. ↳Blocking Process\nc. ↳Interrupts in ATMega328P Putting it All Together\na. ↳Writing Bytes to the Shift Register\nb. ↳The Animation\nc. ↳Interrupt for Interface\nd. ↳Result Conclusion ↳Nomenclature of the 7400 series IC (trivia) References and Further Reading Foot Notes Overview # Bagaimana caranya menganimasikan 8 LED dengan mikrokontroler? Cara paling sederhana adalah menggunakan 8 pin GPIO dari port yang sama. Contoh, jika kita menggunakan Port B, maka kita perlu mengubah register DDRB sekali dan memanipulasi PORTB untuk setiap frame-nya. Selesai.\nTapi terdapat masalah lain, jumlah pin GPIO pada MCU sangatlah terbatas. Beberapa MCU bahkan hanya memiliki 6 GPIO. Atau, meskipun jumlah pin yang dimiliki melimpah, kita tidak tahu pada update versi selanjutnya akan membutuhkan berapa banyak pin.\nSalah satu solusi yang dapat digunakan adalah IC Shift Register Serial In Parallel Out, yang akan kita gunakan adalah IC SN74HC595. Sementara IC tersebut menangani 8 LED, digunakan 3 tombol sebagai interface: previous, restart, dan next. Interrupt akan mendeteksi ketika salah satu tombol ditekan. Itulah yang akan kita bahas kali ini.\nSebenarnya, ATMega328P memiliki pin yang cukup untuk menangani 8 LED dengan port yang sama. But, let\u0026rsquo;s do it anyway.\nCatatan: Blog ini tidak ditujukan sebagai tutorial atau blog singkat, melainkan \u0026rsquo;technical walkthrough\u0026rsquo; tentang program yang saya buat. Itulah mengapa blog ini cukup panjang.\nShift Register # Kata \u0026ldquo;register\u0026rdquo; pada shift register secara konsep sama saja seperti register yang ada pada MCU. Register is register. Yang membedakan adalah kata \u0026ldquo;shift\u0026rdquo; (geser). Jadi, shift register adalah salah satu jenis register yang bisa menggeser data di dalamnya dari bit 0 ke bit 1, bit 1 ke bit 2, dan seterusnya ketika diberi sinyal clock.\nDi dalam MCU juga terdapat internal shift register, tapi kali ini kita hanya membahas tentang external shift register dalam bentuk Integrated Circuit (IC). Karena ini eksternal, satu-satunya cara untuk memanipulasi register adalah dengan mengirimkan sinyal elektrik HIGH dan LOW. Alih-alih melakukan assignment seperti PORTB = 0x3F; pada program MCU.\nTerdapat dua jenis shift register: Serial In Parallel Out (SIPO), dan Parallel In Serial Out (PISO). Yang akan kita gunakan adalah SIPO karena kita ingin mengurangi penggunaan pin MCU.\nCatatan: Mulai sekarang sampai blog ini selesai, SR berarti Shift Register. Perlu diingat bahwa terdapat makna lain dari SR.\nIC SN74HC595 # Overview # Ilustrasi shift register, sumber lastminuteengineers.com 74HC595 adalah Integrated Circuit yang berguna untuk mengubah input serial menjadi output paralel (SIPO) dengan kapasitas maksimal 8-bit. Di dalamnya, terdapat dua macam register:\nshift register berguna sebagai \u0026ldquo;antrean\u0026rdquo; data masuk, storage register (disebut juga latch) berguna untuk menyimpan data dari shift register dan diteruskan ke pin output. Data shift register hanya akan disimpan jika pin RCLK (disebut juga latch) diberi perubahan sinyal dari LOW ke HIGH. Pin Descriptions # Pinout SNx4HC595, diambil dari datasheet Texas Instruments (TI). Perlu dicatat bahwa garis di atas pin OE dan RCLK memiliki Acrive Low, pin tersebut akan aktif jika dihubungkan ke ground. Pin Number Pin Name Description 15,1-7 Qa-Qh Parallel Output, diambil dari storage register. 8 GND Ground Pin. 9 Qh' Serial Output untuk merangkai 2 shift register atau lebih (kita abaikan di blog ini). 10 SRCLR Shift Register Clear, aktif ketika terhubung ground. 11 SRCLK Shift Register Clock, akan menggeser data di dalam shift register jika pin ini diberi sinyal dari LOW ke HIGH (rising edge). 12 RCLK Register Clock, saat diberi rising edge data shift register akan disalin ke storage register, sehingga mengubah output. 13 OE Output Enable, aktif ketika terhubung ke ground 14 SER Serial data, jalur masuk data serial. 16 VCC Suplai tegangan dari -0.5V sampai dengan 7V. Functional Characteristics # Tabel mode fungsi SNx4HC595, diambil dari datasheet TI. Untuk memahami tabel di atas, berikut beberapa penjelasan untuk masing-masing jenis input:\nX: Don\u0026rsquo;t care, tidak peduli input yang diberikan, H: HIGH, L: Low, ↑: Rising edge, ketika sinyal berubah dari LOW ke HIGH. Pada tabel fungsi, perubahan data dipicu oleh sinyal clock. Yang diperhatikan bukan sinyal HIGH atau LOW, tetapi transisi dari LOW ke HIGH (rising edge).\nBerikut adalah penjelasan masing-masing mode:\nFungsi 1 dan 2, untuk mengaktifkan pin output (Qa-Qh), pin OE harus disambungkan ke ground. Fungsi 3, kita perlu menghubungkan pin SRCLR ke VCC agar SR tidak di-clear. Fungsi 4, ketika SER bernilai LOW, SRCLR HIGH, dan memberi SRCLK sinyal clock: SR akan bergeser dan bit pertama bernilai 0. Fungsi 5, Sama seperti sebelumnya, namun SER bernilai HIGH sehingga SR bergeser dan bit pertama bernilai 1. Fungsi 6, ketika RCLK diberi sinyal clock (rising edge), data di dalam SR akan disalin ke storage register. Jadi, koneksi ke MCU yang perlu ditentukan adalah untuk pin SER, SRCLK, dan RCLK. Sedangkan untuk pin output, masing-masing pin dihubungkan ke katoda LED. Untuk pin lain, OE dihubungkan ke ground, dan SRCLR dihubungkan ke VCC.\nInterrupts # A Brief Description # Interrupt adalah salah satu fungs dasar pada mikrokontroler yang berguna untuk menginterupsi program utama untuk melakukan proses lain yang lebih penting. Secara teknis, interrupt adalah sinyal yang menginformasikan CPU agar menghentikan apapun yang sedang dilakukan untuk sementara waktu. Setelah itu, Interrupt Service Routine (ISR) akan dijalankan. ISR umumnya ditulis dalam bentuk routine/fungsi. Kemudian, CPU kembali melanjutkan proses yang sebelumnya diinterupsi.\nBlocking Process # Perlu diingat bahwa sebuah CPU hanya bisa melakukan satu tugas dalam satu waktu. Sementara itu, proses seperti animasi LED adalah proses yang memakan waktu, sebagian besar waktunya digunakan untuk menunggu beberapa ratus ms agar kita dapat melihat animasinya. Inilah yang disebut blocking process.\nMisalkan kita menambahkan tombol \u0026lsquo;previous\u0026rsquo;, \u0026rsquo;next\u0026rsquo;, dan \u0026lsquo;restart\u0026rsquo; yang berguna untuk mengontrol animasi mana yang diputar. Tanpa interrupt, jika salah satu tombol ditekan maka tombol itu diabakan selama animasi sedang berjalan.\nDengan interrupt, kita bisa menginterupsi di tengah-tengah proses animasi. Kemudian di dalam ISR, ditentukan animasi mana yang harus diputar selanjutnya. Setelah itu, ISR kembali ke proses yang diinterupsi. Bedanya, kali ini fungsi tersebut dihentikan paksa sehingga iterasi main loop juga akan dihentikan paksa.\nInterrupts in ATMega328P # Pada ATMega328P terdapat beberapa macam interrupt, masing-masing memiliki alamat ISR-nya sendiri. Macam sumber interrupt, RESET adalah prioritas tertinggi. Diambil dari datasheet ATMega328P. Pinout ATMega328P DIP-28 dan vector PCINT masing-masing GPIO Sebagai contoh, ketika tombol dengan konfigurasi pull-up resistor ditekan, kondisi pin terkait akan berubah. Maka, untuk menerapkan interrupt, digunakan jenis Pin Change Interrupt (PCINT). Terdapat 3 PCINT (PCINT0-PCINT2), PCINT0 serta PCINT 2 masing-masing menangani 8 pin, dan PCINT1 menangani 7 pin.\nUntuk menggunakan fitur interrupt, sertakan library \u0026lt;avr/interrupt.h\u0026gt;. Secara default interrupt tidak aktif, untuk mengaktifkan interrupt global, pangggil fungsi sei(). Selanjutnya, untuk mengaktifkan interrupt vector spesifik, register interrupt terkait perlu dimanipulasi.\nEIMSK |= (1 \u0026lt;\u0026lt; INT1); sei(); Ekspresi di atas akan memodifikasi EIMSK (External Interrupt Mask Register), mengubah 0 menjadi 1 pada bit INT1. Sehingga interrupt vector INT1 menjadi aktif. Pemanggilan fungsi sei() akan mengaktifkan interrupt secara global.\nKetika terdapat sinyal interrupt INT1 diciptakan, MCU akan segera menjalankan ISR yang sudah didefinisikan:\nISR (INT1_vect) { // isr tasks } ISR dapat diinterupsi oleh interrupt vector yang memiliki prioritas lebih tinggi. Contoh, INT1 dapat diinterupsi oleh INT0 dan RESET.\nProses di dalam ISR sebaiknya dibuat seringkas mungkin. Salah satu cara untuk mempersingkatnya adalah menggunakan variable sebagai flag. Ketika sinyal interrupt diberikan, ISR mengisi flag dengan nilai true. Flag tersebut akan dievaluasi menggunakan control-flow sebelum mengeksekusi suatu proses.\nPutting it All Together # Writing Bytes to the Shift Register # Sebuah LED dapat direpresentasikan sebagai satu bit, delapan LED direpresentasikan menjadi delapan bit atau satu byte. Delapan LED tersebut selanjutnya dihubungkan ke output parallel IC shift register, SN74HC595. Sekarang, kita perlu mencari cara untuk mengirimkan data secara serial ke dalam IC tersebut.\nDengan mengabaikan pin-pin output dan pin lain yang terhubung ke ground atau VCC, berikut adalah pin yang tersisa dan perlu dihubungkan ke ATMega328P:\nSRCLK (11) ke PD0 (2), RCLK (12) ke PD1 (3), dan SER (14) ke PD2 (4). Pin-pin di atas digunakan dalam fungsi-fungsi primer yang melakukan: bit shifting, trigger SR clock, latch SR ke output.\n*Catatan: Nomor pin SN74HC595 mengacu package DIP-16, dan ATMega328P DIP-28\n// shiftreg.c #define SER PD0 #define R_CLK PD1 #define SR_CLK PD2 void tick(void) { PORTD |= (1 \u0026lt;\u0026lt; SR_CLK); _delay_ms(1); PORTD \u0026amp;= (~(1 \u0026lt;\u0026lt; SR_CLK)); } Ketika routine tick() dieksekusi, data shift register akan digeser dengan nilai bit ke-0 mengikuti nilai SER atau PD0 pada saat fungsi dieksekusi. Hal ini sesuai dengan karakteristik SR pada datasheet yang sudah kita bahas.\n// shiftreg.c void shift_bit(bool bit) { if (bit) PORTD |= (1 \u0026lt;\u0026lt; SER); else PORTD \u0026amp;= (~(1 \u0026lt;\u0026lt; SER)); tick(); } Fungsi shift_bit(bool bit) menerima boolean sebagai parameter. Boolean tersebut dijadikan sebagai nilai PD0. Setelah nilai PD0 diubah, fungsi tick() dipanggil sehingga bit ke-0 pada SR ditentukan oleh parameter bit.\n// shiftreg.c bool latch(void) { PORTD |= (1 \u0026lt;\u0026lt; R_CLK); _delay_ms(1); PORTD \u0026amp;= (~(1 \u0026lt;\u0026lt; R_CLK)); if (restart_requested) { restart_requested = false; return false; } return true; } Fungsi latch() akan menyalakan R_CLK atau PD1 selama 1ms. Sesuai datasheet, high pada RCLK akan menyalin data pada SR ke storage register yang menyimpan nilai output.\nSelanjutnya, restart_requested yang merupakan variable flag akan diperiksa. Jika bernilai true, flag tersebut akan dikembalikan ke nilai defaultnya. Setelah itu menghentikan eksekusi fungsi latch() dengan return false;.\nProses serupa terjadi secara bertumpuk/bersarang, fungsi yang memanggil latch() dan mendapatkan nilai false akan mengakhiri dirinya dengan mengembalikan nilai false. Dan seterusnya.\nSehingga ketika sinyal interrupt diberikan, semua proses secara instan akan terhenti dan memulai ulang main-loop untuk memulai animasi sebelumnya, selanjutnya, atau memulai ulang animasi saat ini.\n// shiftreg.c bool sr_write(uint8_t data) { for (int i=0; i\u0026lt;8; i++) { shift_bit(data \u0026amp; 0x80); data \u0026lt;\u0026lt;= 1; } return latch(); } Fungsi sr_write(uint8_t data) menerima parameter data yang berukuran 8-bit. Fungsi tersebut memasukkan data bit-demi-bit ke dalam SR dimulai dari Most Significant Bit (MSB First).\nDi dalam setiap iterasi for, bit paling kiri (data \u0026amp; 0x80) dimasukkan ke dalam SR. Selanjutnya, variabel data akan digeser 1 posisi ke kiri.\nSetelah semua bit dimasukkan ke dalam SR, fungsi latch() dipanggil.\nThe Animation # Tiga fungsi yang telah dibuat, pada akhirnya digunakan untuk menyala-matikan 8 LED yang terhubung ke IC SR.\nUntuk menampilkan animasi, kita perlu memanipulasi SR untuk menampilkan frame selama beberapa ms, kemudian menampilkan frame selanjutnya. Satu frame direpresentasikan oleh uint8_t, masing-masing bitnya menentukan nyala-mati satu buah LED.\n// anim.c #include \u0026lt;util/delay.h\u0026gt; #include \u0026lt;anim.h\u0026gt; bool draw_pattern(uint8_t pattern, int delay_ms) { if (!sr_write(pattern)) return false; for (int i = 0; i \u0026lt; delay_ms; i++) { _delay_ms(1); } return true; } Fungsi draw_pattern(uint8_t pattern, int delay_ms) menampilkan pattern setidaknya selama delay_ms.\nPerlu diingat bahwa fungsi _delay_ms(int) hanya menerima bilangan konstan. Untuk mengakalinya, digunakan for loop dengan iterasi sebanyak delay_ms, di mana setiap iterasinya melakukan delay selama 1ms.\n// anim.c void binary_counter() { for (int i=0; i\u0026lt;256; i++) { if (!draw_pattern(i, 30)) return; } } Fungsi binary_conter() akan melakukan iterasi dari 0-255, nilai biner dari pencacah i kemudian ditampilkan selama 30ms.\nEmulasi shift register untuk animasi binary_counter() melalui CLI. // anim.c void bounce_left_right() { for (int i=0; i\u0026lt;8; i++) { if (!draw_pattern((1 \u0026lt;\u0026lt; i), 80)) return; } for (int i=7; i\u0026gt;=0; i--) { if (!draw_pattern((1\u0026lt;\u0026lt;i), 80)) return; } } Selain menggunakan nilai biner dari suatu bilangan, operasi bitwise juga dapat digunakan untuk melakukan animasi. Fungsi bounce_left_right() menampilkan \u0026ldquo;bola\u0026rdquo; yang memantul dari kanan ke kiri dan sebaliknya.\nEmulasi shift register untuk animasi bounce_left_right() melalui CLI. // anim.c void left_sign(int len) { for (int i=0; i\u0026lt;8; i++) { if (i\u0026lt;len) { shift_bit(1); } else { shift_bit(0); } if (!latch()) return; _delay_ms(150); } } Routine left_sign(int len), alih-alih memanggil fungsi seperti sr_write atau draw_pattern, ia menggunakan fungsi yang lebih dasar. shift_bit dan latch.\nRoutine di atas akan melakukan bit shifting bernilai 1 sebanyak len kali, dan 0 sebanyak 8-len kali. Animasi yang dihasilkan adalah LED sejumlah len bergeser ke kiri seperti lampu sign kendaraan.\nEmulasi shift register untuk animasi left_sign(int len) melalui CLI. // anim.h #include \u0026lt;stdint.h\u0026gt; bool draw_pattern(uint8_t pattern, int delay); void hello_world(); void binary_counter(); void stack_to_end(); void bounce_left_right(); void left_sign(int); void loading_bar(); void random_spark(); void waterdrop(); void heartbeat(); File header di atas mendefinisikan fungsi-fungsi animasi. File tersebut akan disertakan pada anim.c dan shiftreg.c. Program lengkap dapat ditemukan di repo github berikut.\nInterrupt for Interface # // shiftreg.c #include \u0026lt;avr/io.h\u0026gt; #include \u0026lt;avr/interrupt.h\u0026gt; #include \u0026lt;util/delay.h\u0026gt; #include \u0026lt;stdbool.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #define F_CPU 16000000UL #define SER PD0 #define R_CLK PD1 #define SR_CLK PD2 #define ANIM_NUM 9 bool sr_write(uint8_t data); void shift_bit(bool bit); void tick(void); bool latch(void); #include \u0026lt;anim.h\u0026gt; volatile bool restart_requested = false; volatile int mode = 0; int main(void) { DDRD |= (1 \u0026lt;\u0026lt; SER) | (1 \u0026lt;\u0026lt; R_CLK) | (1 \u0026lt;\u0026lt; SR_CLK); // three output pins PORTD |= (1 \u0026lt;\u0026lt; PD5) | (1 \u0026lt;\u0026lt; PD6) | (1 \u0026lt;\u0026lt; PD7); // three pull-up button interface PCICR |= (1 \u0026lt;\u0026lt; PCIE2); // enable PCINT2 PCMSK2 |= (1 \u0026lt;\u0026lt; PCINT21) | (1 \u0026lt;\u0026lt; PCINT22) | (1 \u0026lt;\u0026lt; PCINT23); // enable PCINT2 for three pins ADCSRA |= (1 \u0026lt;\u0026lt; ADEN); ADMUX = 0x00; ADCSRA |= (1 \u0026lt;\u0026lt; ADSC); while(ADCSRA \u0026amp; (1 \u0026lt;\u0026lt; ADSC)); srand(ADC); // seed PRNG with ADC noise sei(); // enable global interrupt while (true) { switch (mode) { case 0: hello_world(); break; case 1: binary_counter(); break; case 2: bounce_left_right(); break; case 3: left_sign(3); break; case 4: stack_to_end(); break; case 5: loading_bar(); break; case 6: random_spark(); break; case 7: waterdrop(); break; case 8: heartbeat(); break; default: hello_world(); break; } } } File shiftreg.c adalah file utama program ini. Terdapat variable global volatile restart_requested sebagai flag interrupt, dan mode menentukan animasi mana yang perlu diputar.\nVariabel mode bertipe data integer dengan nilai maksimal adalah ANIM_NUM - 1 yang menyatakan banyaknya animasi yang tersedia.\nUntuk mengubah animasi yang diputar, digunakan tiga tombol interface: previous, restart, next. Karena animasi merupakan proses blocking, digunakan interruptuntuk mendeteksi aksi pada tombol.\nPORTD |= (1 \u0026lt;\u0026lt; PD5) | (1 \u0026lt;\u0026lt; PD6) | (1 \u0026lt;\u0026lt; PD7); // three pull-up button interface PCICR |= (1 \u0026lt;\u0026lt; PCIE2); // enable PCINT2 PCMSK2 |= (1 \u0026lt;\u0026lt; PCINT21) | (1 \u0026lt;\u0026lt; PCINT22) | (1 \u0026lt;\u0026lt; PCINT23); // enable PCINT2 for three pins Pada baris pertama, sinyal PD5, PD6, dan PD7 diatur menjadi HIGH. Masing-masing pin tersebut dihubungkan ke Vcc. Ketika tombol ditekan, pin akan dialirkan ke ground sehingga nilai pin terkait berubah menjadi LOW. Ini disebut pull-up button.\nTombol pull-up. Sumber: learn.sparkfun.com Pada baris kedua Pin Change Interrupt kedua diaktifkan. Baris selanjutnya, PCMSK2 (Pin Change Mask 2) dimanipulasi sehingga PCINT21 (PD5), PCINT22, (PD6), PCINT23 (PD7) dapat mengirimkan sinyal interrupt ketika terjadi perubahan sinyal.\nISR (PCINT2_vect) { _delay_ms(25); restart_requested = true; if ((~(PIND \u0026gt;\u0026gt; PD5)) \u0026amp; 1) { if (mode) { mode--; } else { mode = ANIM_NUM-1; } } else if ((~(PIND \u0026gt;\u0026gt; PD7)) \u0026amp; 1) { if (mode==(ANIM_NUM-1)) { mode = 0; } else { mode++; } } } ISR di atas menangani tiga tombol interface. Saat ISR pertama kali dijalankan, MCU perlu menunggu 25ms untuk mengabaikan bouncing signal. Sinyal oscilloscope pull-up button ketika tombol ditekan. Sumber: circuitcellar.com Ketika tombol mekanik ditekan, kontak yang dihasilkan tidak langsung sempurna. Alih-alih, terjadi fluktuasi seperti gambar di atas. Fluktuasi di atas disebut bouncing signal.\nTerdapat beberapa teknik untuk debouncing (mengurangi sinyal fluktuasi). Dapat menggunakan solusi hardware maupun software. Solusi sederhana dengan software adalah menunggu selama beberapa ms sampai sinyal tersebut stabil, seperti yang dilakukan _delay_ms(25)*.\nSetelah debouncing, restart_requested diubah menjadi true sehingga semua fungsi latch() dan yang memanggilnya akan terhenti begitu ISR selesai dijalankan.\nSelanjutnya, blok control-flow mengevaluasi jika tombol yang ditekan terhubung dengan PD5 (tombol previous). Jika benar, nilai mode akan dikurangi 1, atau kembali ke nilai ANIM_NUM-1 sehingga mode tidak akan bernilai negatif.\nJika salah, else if akan memeriksa jika tombol yang ditekan terhubung dengan PD7 (tombol next). Jika benar, nilai mode akan diubah ditambah 1, atau kembali ke 0 sehingga mode akan selalu lebih kecil dari ANIM_NUM.\n*Catatan: penggunaan delay di dalam ISR sangat tidak direkomendasikan karena merupakan proses blocking. Sebaiknya gunakan timer interrupt. Namun kali ini kita gunakan delay, timer akan dibahas di blog selanjutnya.\nResult # Conclusion # Sekedar kilas balik, kita sudah membahas tentang shift register, karakteristik ic sn74hc595, interrupts, dan program c.\nOverall Schematic Gambar di atas adalah diagram rangkaian secara keseluruhan. Kode program tersedia di repo repo github.\nPada technical blog selanjutnya, kita akan mencoba menampilkan sesuatu ke 7-segment display dan 8x8 matrix sekaligus menggunakan 2 buah ic driver yang disusun berantai, max7219. Kita akan menggunakan beberapa peripheral ATMega328P lainnya yakni SPI dan Timer.\nNomenclature of the 7400 series IC (trivia) # IC 74HC595 memiliki makna dalam penamaannya. Untuk deskripsi lebih detail Anda dapat meninjau laman Wikipedia berikut: 7400-series Integrated Circuits. Berikut adalah ringkasannya:\nKode 74 di depan merepresentasikan temperatur operasinya: HC adalah singkatan dari Highspeed CMOS, ini adalah kode family line. Terdapat banyak family line lain seperti L (Low Power), C (CMOS), F (Fast), dan masih banyak lagi. Untuk lebih detailnya silakan baca di sini. Sedangkan 595 adalah kode subfamily. Banyak subfamily lain seperti 165 (SIPO SR), 00 (Quad AND Gate), 114 (Dual J-K Flip-Flop), dsb. IC 7400 series ini didesain oleh perusahaan asal Amerika, Texas Instruments. Namun, perusahaan lain memiliki lisensi untuk memproduksi seri ini. Sehingga, diberikan prefiks untuk memberi keterangan perusahaan yang memproduksinya: References and Further Reading # GitHub: vfadlan/avr-exp/05-shiftreg ATMega328P Datasheet SNx4HC595 Datasheet The C Programming Language (2nd Edition) by Brian Kernighan and Dennis Ritchie TI Application Note: Designing with Shift Registers Switch Debouncing, Article from circuitcellar.com 7400-Series Integrated Circuit, Article from wikipedia.org ","date":"12 January 2026","externalUrl":null,"permalink":"/posts/avr/01-shift-register/","section":"Posts","summary":"","title":"Animating LEDs with Shift Register","type":"posts"},{"content":" For the past few months, I’ve been dabbling in some low-level programming. Was focused with the C language. The C Programming Language (Second Edition) by Kernighan \u0026amp; Ritchie is my reference and guide book. That book is the \u0026ldquo;Holy Bible\u0026rdquo; of C; it packs all the essential knowledge into less than 300 pages, whereas most technical books take more than 400. Later on, at late November, I also started working with bare-metal AVR.\nThis series documents my journey diving into low-level version of Arduino (ATMega328P).\nBare Metal AVR # What is it? Bare Metal means running software directly on physical computer hardware without an excessive abstraction layer. AVR is a computer architecture for ATmega and ATTiny microcontrollers. The MCU that I use is the ATMega328P, the one used by the Arduino UNO Development Board.\nI simply unplugged that chip from the Arduino Dev Board and ran my code directly on that chip. The ATMega328P can be programmed using a programmer, which is quite of a hurdle to do.\nPict. 1: USBASP Programmer, the one that I use. Pict. 2: ATMega328P 28 pin DIP Pinout. Blue-highlighted text is connected to USBASP pinouts using jumper wires. Arduino Works Perfectly Fine, Why All These Hurdles? # Well, first things first, the Arduino Development Board is a quick prototyping board that speeds up development. That’s why you’ll never see any device in the big electronic market that uses the Arduino Dev Board. It’s meant for development, not production.\nArduino run upon an Microcontroller Unit (MCU), which is the ATMega328P. There are tons of MCU families out there; STM32, PIC, MSP, Renesas, and AVR are the most commonly used MCUs in the market.\nSecond, it runs faster. By stripping off the Arduino abstractions, we can write a plain C program and flash it to the chip. Here’s a comparison between Arduino .ino code and its C equivalent:\nThe Arduino Code:\nvoid setup() { // setup here } void loop() { // the code that loops forever } C Code:\nint main() { // setup here while (1) { // the code that loops forever } } You see, Arduino is just an abstraction layer. Which is good if you want high portability and fast prototyping. But the abstraction itself is slow in terms of performance.\nIt won\u0026rsquo;t matter if you just blink an LED every one second, but if you\u0026rsquo;re doing something that requires you to have precise timing, even a millisecond matters.\nThose two are my reasons. The third is my motive: to challenge myself.\nRegisters # Just like any other computer, an MCU contains a CPU (Central Processing Unit). Inside it, there’s a small high-speed memory called registers that hold data temporarily during the execution cycle of the program. These registers control how the GPIO, ADC, Timers, and any other peripherals should behave.\nThe structure of each register is usually specified in the corresponding MCU Datasheet or Reference Manual. For example, if we want pin 15 to blink an LED, we have to dive into the datasheet:\nPict 3: ATMega328P 28 pin DIP Pinout. Source: ATMega328P Datasheet. Pin 15 is identified as PB1. Each pin port has three registers: DDRx, PORTx, and PINx (x can be B, C, or D). Since we just want to output things, we can ignore the PINx register. DDRB: Data Direction B Register\nThis register handles the direction of data. As you can see below, there are 8 bits of data. Each bit corresponds to a single pin (PB0-PB7). Default value is 0, which means it will act as input. Otherwise, it will act as an output. Pict 4: DDRB Register. Source: ATMega328P Datasheet. To set PB1 as an output, we should set bit-1 at the DDRB register as 1. PORTB Data Register\nThe PORTB register handles what signal each pin should send. It can be either HIGH or LOW, 1 or 0. To turn on the LED, simply set 1 to bit-1 at the PORTB register. Pict 5: PORTB Data Register. Source: ATMega328P Datasheet. Bitwise Operators # To handle all these bit-by-bit operations I had to equip myself with the right tool: bit-wise operators. This operator simply gives me bit-wise manipulation techniques:\nClearing a bit on a register REG \u0026amp;= (~(1\u0026lt;\u0026lt;TARGET_BIT)); Setting a bit REG |= (1\u0026lt;\u0026lt;TARGET_BIT); Rotating a bit ROTATED = (REG\u0026lt;\u0026lt;3) | (REG\u0026gt;\u0026gt;(8-3)) Extracting a bit from registers DATA = (REG \u0026gt;\u0026gt; 4) Many other operations Input # There are many ways to receive an input signal. You can receive it from some communication channel, sensor, or a simpler one, like a switch button and a potentiometer.\nFor handling digital input, it’s quite easy. What we do is the opposite of sending an output signal. We read the PINx register.\nBut an analog signal is slightly more complicated than that. Firstly you have to do the conversion from analog to digital signal. In doing so, there are some registers that you should take care of: DDRx, PORTx, PINx, ADMUX, ADCSRA. And, if you manage to start the ADC process, the MCUs will store the output into two separate registers, ADCL and ADCH. They’re separated because ATMega328P have 10 bits ADC, while a register can only store up to 8 bits.\nFirst Project: Morse Code # I have done some easy things with this low-level stuff. But I wouldn’t call them projects; exercise is the perfect description for that.\nMy first project is to encode a string into visible and audible Morse code (LEDs and buzzer). The code and schematics are available on my repo, see below. You can watch it on YouTube if you want:\nJust like any other system, here\u0026rsquo;s how it works from input, process, to output:\nThe input. My program will accept two digital inputs and one analog input.\nThe analog input is a signal from a potentiometer. It reads the voltage from 0v to 5v. The digital inputs are simply two switches, pull-up and pull-down. It is responsible for telling the MCU when to send the Morse code. The pull-up one will make the CPU send a “Hello World” in Morse code. The other one will send the value of that analog input. The process. Some of the main processes are:\n26 letters of alphabets -\u0026gt; Morse code. It only uses switch case, and call two routines: dot(), dash(). This part is the most bad-looking code in my program, but at least it works. ADC. This process will start right after the pull-down switch is triggered. The output will be stored in an int and converted to a string. Later on, it will be sent to the output. The output. There are two types of Morse code that will be sent by this program:\n“Hello World” The value of that analog input ranges from 0 (represents 0v) to 1023 (represents 5v). For the ‘how’ Morse code is being sent, there are three LEDs (RGB) and a buzzer. Like I said, visible and audible. Each one indicates a different meaning:\nRed LED blinks briefly = dot. Green LED blinks shortly = dash. Blue LED = separation. Separate words or indicate the starting point. Conclusion # The shift from high-level to low-level gives me some kind of reward that I can\u0026rsquo;t explain by mere words. I\u0026rsquo;ll try.\nIt gives me a broader yet deeper picture of how things work on a system. Stripping down the abstractions somehow makes me appreciate more about the everyday device around me. How such a simple thing has been engineered multiple times through trials and errors.\nIn simple terms, I am grateful for abstraction.\nNext interesting things # Thank you for spending your time reading all these yaps. It\u0026rsquo;s an interesting for me to drive a device without the use of external excessive library. Especially for learning things, I\u0026rsquo;d rather write my own driver. Here are things that I might do later:\nDriving LED with Shift Register (74HC595) Driving 7 Segment Display with MAX7219 Driving 8x8 Matrix LED Display with MAX7219 Bit banging the 16x02 LCD to show text Bit banging in rhytm to control WS2812B addressable RGB LED Links # GitHub: vfadlan/avr-exp/04-potensio-adc ATMega328P Datasheet ","date":"22 December 2025","externalUrl":null,"permalink":"/posts/avr/00-hello/","section":"Posts","summary":"","title":"Hello, Bare Metal AVR.","type":"posts"},{"content":"It’s been a long time since I published my first blog; it was more than 6 months ago. Now here it is, I set up my own blog on a new, completely free platform.\nThe Shift # As of November 6th, 2025, the domain name of fadlanabduh.com has expired. I didn’t have enough money to renew it, and now it costs me more than $110+ USD for the late renewal fee (fine).\nPreviously, I used Google Sites + blogspot for all my websites. Now that I don’t have a domain, using them is not that good for SEO.\nSo, I switched to GitHub Pages for my main web and blogging platform.\nStatic Site Generator (SSG) # I use this thing called Hugo SSG, and I use some open-source template for the sake of time. Here’s basically how it works:\nI set up the site: template, configs, GitHub repo, and pages, etc. Write content in forms of Markdown inside the content/ directory. Push it to a GitHub Repository. Github Action format every .md (markdown) file inside content/ to some .html Those .html will be accessible via GitHub Pages. What’s Coming Next # I don’t know what I’m going to post on this new blogsite that I set up overnight. Maybe this blog is simply just a (rushed) realization of my 2025 goal; it might (or might not) continue. I can only promise one thing from this blogsite: I post more often here compared to other social media (Instagram, Facebook, etc).\n","date":"21 December 2025","externalUrl":null,"permalink":"/posts/new-blogsite/","section":"Posts","summary":"","title":"New Blogsite","type":"posts"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"}]